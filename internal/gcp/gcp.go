package gcp

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"cloud.google.com/go/iam"
	admin "cloud.google.com/go/iam/admin/apiv1"
	"cloud.google.com/go/storage"
	"github.com/pkg/errors"
	"golang.org/x/oauth2"
	"google.golang.org/api/option"
	adminpb "google.golang.org/genproto/googleapis/iam/admin/v1"

	"github.com/athera-io/gcs-bucket-helper/internal/executor"
	validateBucket "github.com/athera-io/gcs-bucket-helper/internal/gcp/validate/bucket"
	validateSA "github.com/athera-io/gcs-bucket-helper/internal/gcp/validate/serviceaccount"
	"github.com/athera-io/gcs-bucket-helper/internal/input"
	"github.com/athera-io/gcs-bucket-helper/internal/tilde"
	"github.com/google/uuid"
)

// GCP is responsible for executing GCP operations
type GCP struct {
	// Both clients are instantiated after we have a token
	storageClient *storage.Client
	iamClient     *admin.IamClient
}

// New ...
func New() *GCP {
	return &GCP{}
}

func (g *GCP) instantiateClients(ctx context.Context, tok *oauth2.Token) error {
	tokSource := oauth2.StaticTokenSource(tok)

	storageClient, err := storage.NewClient(ctx, option.WithTokenSource(tokSource))

	if err != nil {
		return errors.Wrap(err, "Failed instantiating GCP Storage Client")
	}

	g.storageClient = storageClient

	iamClient, err := admin.NewIamClient(ctx, option.WithTokenSource(tokSource))

	if err != nil {
		return errors.Wrap(err, "Failed instantiating GCP IAM Service Account Client")
	}

	g.iamClient = iamClient

	return nil
}

// Execute ...
func (g *GCP) Execute(tok *oauth2.Token, data *executor.Data) error {

	ctx := context.Background() // Make new context so that server can return authentication success to user

	if err := g.instantiateClients(ctx, tok); err != nil {
		return err
	}

	defer func() {
		if err := g.iamClient.Close(); err != nil {
			log.Print("Error: Failed closing GCP IAM Service Account Client: ", err)
		}
	}()

	fmt.Println("") // Line break for legibility

	g.fillData(ctx, data)

	serviceAccount, err := g.makeServiceAccount(ctx, data)

	if err != nil {
		return err
	}

	// Sleep avoids race condition where Google sometimes does not recognize service account that was just created
	time.Sleep(time.Second)

	return g.makeBucket(ctx, serviceAccount, data)
}

func (g *GCP) fillData(ctx context.Context, data *executor.Data) {
	data.GCP.Project = input.Recv("Enter your GCP project name:")

	data.GCP.Bucket = uuid.New().String()

	fmt.Printf("- We have autogenerated the bucket name: %s.\n", data.GCP.Bucket)

	inputBucketName := input.Recv(
		"If you want to override the autogenerated name then input a name, otherwise leave blank:",
		// Bucket with that name must not already exist
		func(bucketName string) error {
			return validateBucket.CheckExist(ctx, bucketName, g.storageClient)
		},
		// Name must not contain illegal characters
		validateBucket.LegalChars,
		// Name must start and end with number or lower-case letter
		validateBucket.StartAndEndAlphanumeric,
		// Name must be appropriate length
		validateBucket.Length,
		// Name must not contain illegal substrings
		validateBucket.IllegalSubstrings,
	)

	if inputBucketName != "" {
		data.GCP.Bucket = inputBucketName
	}
}

func (g *GCP) makeServiceAccount(ctx context.Context, data *executor.Data) (*adminpb.ServiceAccount, error) {

	createServiceAccountReq := &adminpb.CreateServiceAccountRequest{
		Name:      "projects/" + data.GCP.Project,
		AccountId: genServiceAccountID(data),
	}

	serviceAccount, err := g.iamClient.CreateServiceAccount(ctx, createServiceAccountReq)

	if err != nil {
		return nil, errors.Wrap(err, "Failed creating IAM Service Account")
	}

	createServiceAccountKeyReq := &adminpb.CreateServiceAccountKeyRequest{
		Name: serviceAccount.Name,
	}

	serviceAccountKey, err := g.iamClient.CreateServiceAccountKey(ctx, createServiceAccountKeyReq)

	if err != nil {
		return nil, errors.Wrap(err, "Failed creating IAM Service Account Key")
	}

	data.GCP.ServiceAccountPrivateData = serviceAccountKey.PrivateKeyData

	serviceAccountJSONPath := input.Recv(
		"Enter a path to a directory on your local machine to save your service account credentials. This is the key used by Athera to access your bucket:",
		// Directories in path must already exist
		validateSA.PathExists,
	)

	serviceAccountJSONPath, err = tilde.ExpandPath(serviceAccountJSONPath)

	if err != nil {
		return nil, err
	}

	serviceAccountJSONPath = filepath.Join(serviceAccountJSONPath, createServiceAccountReq.AccountId+".json")

	fmt.Println("- Saving service account credentials at " + serviceAccountJSONPath)

	f, err := os.Create(serviceAccountJSONPath)

	if err != nil {
		return nil, errors.Wrap(err, "Failed creating Service Account JSON file")
	}

	defer f.Close()

	if _, err := f.Write(serviceAccountKey.PrivateKeyData); err != nil {
		return nil, errors.Wrap(err, "Failed writing service account key")
	}

	return serviceAccount, nil
}

// isDirectoryName returns true if filename is a directory name.
// (N.B. We assume that if the filename has no extension, then the user intended last element in path to represent a directory)
func isDirectoryName(s string) bool {
	ls := strings.Split(s, ".")

	// No extension if there is no "." char
	return len(ls) == 1 ||
		// No extension if there is only one "." char, and that char is a prefix (because "." prefix represents hidden file, not extension)
		(len(ls) == 2 && strings.HasPrefix(s, "."))
}

func genServiceAccountID(data *executor.Data) string {
	maxServiceAccountIDLength := 30
	prefix := "athera-"
	bucketName := data.GCP.Bucket

	now := time.Now().Unix()
	timestamp := "-" + strconv.Itoa(int(now))

	for {
		// It is safe to measure bytes instead of runes because:
		// "Bucket names must contain only lowercase letters, numbers, dashes (-), underscores (_), and dots (.)".
		// Therefore, all legal characters have length of 1 byte
		// https://cloud.google.com/storage/docs/naming
		if len(prefix+bucketName+timestamp) > maxServiceAccountIDLength {
			bucketName = bucketName[:len(bucketName)-1]
		} else {
			break
		}
	}

	return prefix + bucketName + timestamp
}

func (g *GCP) makeBucket(ctx context.Context, serviceAccount *adminpb.ServiceAccount, data *executor.Data) error {

	bkt := g.storageClient.Bucket(data.GCP.Bucket)

	bucketRegion := input.Recv("Enter a region for your new GCS bucket (e.g. US, EU):")

	bktAttrs := &storage.BucketAttrs{
		Name:     data.GCP.Bucket,
		Location: bucketRegion,
	}

	if err := bkt.Create(ctx, serviceAccount.ProjectId, bktAttrs); err != nil {
		return errors.Wrap(err, "Failed creating GCS Bucket")
	}

	var policy iam.Policy
	policy.Add("user:"+data.User.Email, "roles/storage.admin")
	policy.Add("serviceAccount:"+serviceAccount.Email, "roles/storage.objectAdmin")

	iamHandle := bkt.IAM()

	if err := iamHandle.SetPolicy(ctx, &policy); err != nil {
		return errors.Wrap(err, "Failed setting Iam Policy")
	}

	return nil
}
